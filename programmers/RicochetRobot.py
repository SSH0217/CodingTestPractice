# 문제 설명
# 리코쳇 로봇이라는 보드게임이 있습니다.
# 이 보드게임은 격자모양 게임판 위에서 말을 움직이는 게임으로, 시작 위치에서 목표 위치까지 최소 몇 번만에 도달할 수 있는지 말하는 게임입니다.
# 이 게임에서 말의 움직임은 상, 하, 좌, 우 4방향 중 하나를 선택해서 게임판 위의 장애물이나 맨 끝에 부딪힐 때까지 미끄러져 이동하는 것을 한 번의 이동으로 칩니다.
# 다음은 보드게임판을 나타낸 예시입니다.

# ...D..R
# .D.G...
# ....D.D
# D....D.
# ..D....
# 여기서 "."은 빈 공간을, "R"은 로봇의 처음 위치를, "D"는 장애물의 위치를, "G"는 목표지점을 나타냅니다.
# 위 예시에서는 "R" 위치에서 아래, 왼쪽, 위, 왼쪽, 아래, 오른쪽, 위 순서로 움직이면 7번 만에 "G" 위치에 멈춰 설 수 있으며, 이것이 최소 움직임 중 하나입니다.

# 게임판의 상태를 나타내는 문자열 배열 board가 주어졌을 때, 말이 목표위치에 도달하는데 최소 몇 번 이동해야 하는지 
# return 하는 solution함수를 완성하세요. 만약 목표위치에 도달할 수 없다면 -1을 return 해주세요.

# 제한 사항
# 3 ≤ board의 길이 ≤ 100
# 3 ≤ board의 원소의 길이 ≤ 100
# board의 원소의 길이는 모두 동일합니다.
# 문자열은 ".", "D", "R", "G"로만 구성되어 있으며 각각 빈 공간, 장애물, 로봇의 처음 위치, 목표 지점을 나타냅니다.
# "R"과 "G"는 한 번씩 등장합니다.

# 입출력 예
# board	                                                    result
# ["...D..R", ".D.G...", "....D.D", "D....D.", "..D...."]	7
# [".D.R", "....", ".G..", "...D"]	                        -1


# 최소 이동을 찾는 문제로 BFS 알고리즘을 사용한다
from collections import deque

def solution(board):
    # 이동방향 좌 우 상 하
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]
    N = len(board)
    M = len(board[0])

    # BFS를 사용하기 위해 큐 생성
    q = deque()
    # 방문처리를 위한 방문 기록 배열 생성
    # 987654321을 M개 만들고 그걸 N개 만듬 M*N board 배열과 크기가 같음
    visited = [[987654321 for _ in range(M)] for _ in range(N)]

    # 로봇의 위치를 파악해 큐에 넣고, 방문처리 후 종료
    for i in range(N):
        for j in range(M):
            if board[i][j] == "R":
                q.append((i, j, 0))
                visited[i][j] = 0
        if q:
            break
    
    # BFS에서는 큐가 빌때까지 반복
    while q:
        x, y, c = q.popleft()
        # G가 골인지점이므로 이동거리 반환
        if board[x][y] == "G":
            return c
        
        # 4방향 모두 탐색
        for i in range(4):
            nx, ny = x, y
            # 방향 이동시 벽이나 끝까지 가야 멈춤, 따라서 벽을 만나거나 끝일경우 정지
            while 0 <= nx + dx[i] < N and 0 <= ny + dy[i] < M and board[nx+dx[i]][ny+dy[i]] != "D":
                nx += dx[i]
                ny += dy[i]
            # 상하좌우 판단 후 방문(c)를 1 증가시키는데 만약 증가시킨 값보다 원래의 값이 더 클경우에만 저장후 탐색을 위한 큐 append
            if visited[nx][ny] > c+1:
                visited[nx][ny] = c+1
                q.append((nx,ny,c+1))
    
    # BFS 탐색이 종료되었는데도 G에 도달하지 못했으므로 -1 반환
    return -1